---
title: "Intraday Volume and Volatility: Modeling and Prediction"
author: |
  | Shengjie Xiu, Yifan Yu, and Daniel P. Palomar
  | The Hong Kong University of Science and Technology (HKUST)
date: "`r Sys.Date()`"
output: 
  cleanrmd::html_document_clean:
    theme: "bamboo"
    mathjax: default
    toc: yes
    toc_depth: 2
csl: apalike.csl # springer-socpsych-author-date.csl
csl-entry-spacing: 1.2em
bibliography: refs.bib
link-citations: yes
vignette: >
  %\VignetteIndexEntry{Intraday Volume and Volatility: Modeling and Prediction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteKeyword{State-space Model}
---

```{r, echo=FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.retina = 2,
  out.width = "85%",
  dpi = 96,
  pngquant = "--speed=1"
)
knit_hooks$set(pngquant = hook_pngquant)  # brew install pngquant
options(width=100)
```

```{css, echo = FALSE}
/* ensure cleanrmd is centered */
body {
  margin: 0 auto;
  max-width: 750px;
  padding: 2rem;
}

/* math is smaller */
.math {
  font-size: small;
}
```

------------------------------------------------------------------------

> This vignette illustrates the usage of the package `intradayModel` for modeling and prediction of intraday trading volume and volatility.

# Quick Start

Let's load our package and the sample data: the 15-min intraday volume of AAPL from 2019-01-02 to 2019-06-28, including 124 trading days. Each column contains 26 records of intraday volume at a trading day.

```{r}
devtools::load_all() # why here cannot use library(intradayModel)
data(AAPL_volume)
dim(AAPL_volume)
```

We define a univariate state-space model for the intraday signal by

```{r}
modelSpec <- uniModelSpec(fit = TRUE)
```

Let's use the first 104 trading days to fit the model, and the last 20 days to evaluate the prediction performance. To fit the model using the accelerated EM algorithm, we call

```{r}
data <- AAPL_volume
data_train <- AAPL_volume[, 1:104]
modelSpec_fitted <- uniModelFit(data_train, modelSpec, acceleration = TRUE)
```

To evaluate the fitting performance, we use the fitted model to decompose the intraday volume:

```{r}
filter_result <- uniModelFilter(data_train, modelSpec_fitted)
filter_result$plot
```

With the fitted model, we can do one-bin-ahead prediction and evaluate its accuracy.

```{r}
predict_result <- uniModelPred(data, modelSpec_fitted, out.sample = 20)
predict_result$measure
predict_result$plot
```

<!-- # Details (refer to rugarch vignette) -->

# Usage of the package

This package can be used to fit a univariate state-space model for intraday trading volume. Besides, it can be used to predict the one-bin-ahead prediction and decomposition of the intraday volume.

## Datasets

To use this package, the time series object without missing values should be a n_bin \* n_day numeric matrix. For convenience, the package contains two time series objects:

- `AAPL_volume` is a matrix containing the 15-min intraday volume of AAPL from 2019-01-02 to 2019-06-28, including 123 trading days. Each column includes 26 records of intraday volume at a trading day.

- `GE_volume` is a matrix containing the 15-min intraday volume of GE from 2019-01-02 to 2019-06-28, including 123 trading days. Each column includes 26 records of intraday volume at a trading day.

```{r}
library(intradayModel)
data(GE_volume)
```

## Define a model

This section discusses the specification of model via a call to the `uniModelSpec` function.
$$
\begin{aligned}
\mathbf{x}_{t+1} &= \mathbf{A}_{t}\mathbf{x}_{t} + \mathbf{w}_{t},\\
y_{t} &= \mathbf{C}\mathbf{x}_{t} + \phi_{t} + v_t,
\end{aligned}
$$
where:

- $\mathbf{x}_{t} = [\eta_{t}, \mu_{t}]^\top$ is the hidden state vector containing the daily average part and the intraday dynamic part;

- $\mathbf{A}_{t} = \left[\begin{array}{l}a_t^{\eta}&0\\0&a^{\mu}\end{array} \right]$ is the state transition matrix with $a_t^{\eta} = \begin{cases}a^{\eta}&t = kI, k = 1,2,\dots\\0&\text{otherwise}\end{cases}$, $I$ is the number of intervals (referred to as bins) within a day;

- $\mathbf{C} = [1, 1]$ is the observation matrix;

- $\mathbf{w}_{t} = [\epsilon_t^{\eta},\epsilon_t^{\mu}]^\top \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_{t})$ represents the i.i.d. Gaussian noise in the state transition, with diagonal covariance matrix $\mathbf{Q}_{t} = \left[\begin{array}{l}(\sigma_t^{\eta})^2&0\\0&(\sigma_t^{\mu})\end{array} \right]$ and $\sigma_t^{\eta} = \begin{cases}\sigma^{\eta}&t = kI, k = 1,2,\dots\\0&\text{otherwise}\end{cases}$;

- $v_t \sim \mathcal{N}(0, r)$ is the i.i.d. Gaussian noise in the observation;

- $\mathbf{x}_0$ is the initial state, and it is assumed to follow $\mathcal{N}(\overline{\mathbf{x}}_0, \mathbf{V}_0)$.

In the proposed model, $\overline{\mathbf{x}}_0, \mathbf{V}_0, \mathbf{A}_{t},\mathbf{Q}_{t},r$ and the seasonality $\phi = [\phi_1,\dots, \phi_I]^\top$ are treated as the unknown parameters.

We start with the function `uniModelSpec` to define a state-space model without any fixed parameters or given initial value:
```{r}
modelSpec_nofix <- uniModelSpec(fit = TRUE)
```
If we already know the values for some parameters or want to specify the initial guess for certain parameters, then we can set the argument `fixed.par` and `init.par`:
```{r}
# set fixed value
fixed.pars <- list()
fixed.pars$"x0" <- matrix(c(13.33, -0.37), 2)

# set initial value 
init.pars <- list()
init.pars$"a_eta" <- 1

# define the uniModel
modelSpec <- uniModelSpec(fit = TRUE, fixed.pars = fixed.pars, init.pars = init.pars)
```
The components in `fixed.pars` and `init.pars` have the following corresponding relationship as follows:

- `a_eta`: $a^{\eta}$, contains a double;

- `a_mu`: $a^{\mu}$, contains a double;

- `var_eta`: $\sigma^{\eta}$, contains a double;

- `var_mu`: $\sigma^{\mu}$, contains a double;

- `r`: $r$, contains a double;
- `phi`: $\phi = [\phi_1,\dots, \phi_I]^\top$, contains I doubles;

- `x0`: $\overline{\mathbf{x}}_0$, contains two doubles;

- `V0`: $\mathbf{V}_0$, contains three doubles, corresponding to the $\mathbf{V}_0(1,1),\mathbf{V}_0(1,2),\mathbf{V}_0(2,2)$.

## Fit a model
Once a `uniModelSpec` has been defined, the `uniModelFit` function can be applied. It is important to note the argument `acceleration`, which indicates whether a fast method is to be used to estimate the parameters (by default, it is `FALSE`). The `verbose` controls the level of information output during the algorithm iterations (by default, it is `1`):

-`0`: output nothing;

- `1`: output the iteration precision;

- `2`: output the iteration precision and the final model object.

```{r}
data <- AAPL_volume
data_train <- AAPL_volume[, 1:104]
modelSpec_fitted <- uniModelFit(data_train, modelSpec, acceleration = TRUE, verbose = 1)
```

## Filter
A model object with all parameters fixed can be used to decompose the intraday trading volume into daily average, intraday dynamic and intraday periodic parts (i.e., the seasonality). Daily average and intraday dynamic are the smoothed state estimate at time $t$ conditioned on all the data, $\mathbf{x}_t^T$. The seasonality is the value of $\phi$ fitted by the `uniModeFit`.

The return value contains the decomposition result and plots for components:
```{r}
filter_result <- uniModelFilter(data_train, modelSpec_fitted)
filter_result$plot
```

## Predict
A model object with all parameters fixed can be used for one-step ahead prediction and accuracy evaluation with `uniModelPred`. Three performance measures are used to evaluate the prediction results:

- `Mean absolute error (MAE)` : $\frac{1}{M}\sum_{i=1}^M\lvert\hat{\sigma_i} - \sigma_i\rvert$,

- `Mean absolute percent error (MAPE)`: $\frac{1}{M}\sum_{i=1}^M\frac{\lvert\hat{\sigma_i} - \sigma_i\rvert}{\sigma_i}$,

- `Root Mean Square Error (RMSE)`: $\sqrt{\sum_{i=1}^M\frac{\left(\hat{\sigma_i} - \sigma_i\right)^2}{M}}$,

where $\hat{\sigma_i}$ and $\sigma_i$ are the real and predicted values of trading volume and $M$ is the number of bins.

The return value contains the prediction, real value, performance and a plot. We can view the performance and plot:

```{r}
predict_result <- uniModelPred(data, modelSpec_fitted, out.sample = 20)
predict_result$measure
predict_result$plot
```

# References {.unnumbered}

